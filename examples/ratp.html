<!DOCTYPE html>
<html>
    <head>
        <title>RATP PC viewer</title>

        <style type="text/css">
            html {height: 100%;}
            body { margin: 0; overflow:hidden; height:100%}

            #viewerDiv {
                margin : auto auto;
                width: 100%;
                height: 100%;
                padding: 0;
            }

            #menuDiv {position: absolute; top:0px; margin-left: 0px;}
            #info {
                color: black;
                position: absolute;
                top: 0px;
                right: 0px;
                padding: 5px;
                z-index: 100;

                z-index: 100;
                background-color: white;
                border: 2px solid black;
                border-radius: 5px;
            }

            #help {
                color: black;
                position: absolute;
                bottom: 0px;
                right: 0px;
                padding: 5px;
                z-index: 100;
                line-height: 1.5em;

                z-index: 100;
                background-color: white;
                border: 2px solid black;
                border-radius: 5px;
            }
        </style>

        <meta charset="UTF-8">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="GUI/dat.gui/dat.gui.min.js"></script>
    </head>
    <body>
        <div id="viewerDiv"></div>
        <div id="info">

        </div>

        <div id="splat"></div>

        <script src="/examples/GUI/GuiTools.js"></script>
        <script src="/dist/itowns.js"></script>
        <script src="/dist/debug.js"></script>

        <script type="text/javascript">

            /* global itowns,document,GuiTools*/
            const viewerDiv = document.getElementById('viewerDiv');

            itowns.THREE.Object3D.DefaultUp.set(0, 0, 1);

            itowns.proj4.defs('EPSG:3949',
                '+proj=lcc +lat_1=48.25 +lat_2=49.75 +lat_0=49 +lon_0=3 +x_0=1700000 +y_0=8200000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
            itowns.proj4.defs('EPSG:27561',
                '+proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs');
            const bb =  {
                "lx": 1650798.7022,
                "ly": 8181453.994,
                "lz": 35.9102,
                "ux": 1651206.1331,
                "uy": 8181861.4249,
                "uz": 443.3411000000358
            };

            const bbox = new itowns.Extent(
                'EPSG:3949',
                bb.lx, bb.ux,
                bb.ly, bb.uy);

            var camcam = new itowns.THREE.OrthographicCamera(-180, 80, -130, 130, 0, 1000);
            const view = new itowns.View('EPSG:3949', viewerDiv, { camera: camcam });
            const menuGlobe = new GuiTools('menuDiv', view, 460);

            function placeCamera(position) {
                if (position) {
                    view.camera.camera3D.position.set(position.x, position.y, position.z);
                } else {
                    view.camera.camera3D.position.set(1651083.037, 8181534.45, 41.03);
                }
                view.notifyChange(true);
            }

            // point cloud
            function getParameterByName(name, url) {
                if (!url) url = window.location.href;
                name = name.replace(/[\[\]]/g, "\\$&");
                var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                    results = regex.exec(url);
                if (!results) return null;
                if (!results[2]) return '';
                return decodeURIComponent(results[2].replace(/\+/g, " "));
            }
            const withoutQueryStr = window.location.origin + window.location.pathname;
            const path = withoutQueryStr.substr(0, withoutQueryStr.lastIndexOf('/'));
            const data = getParameterByName('data');
            const x = Number.parseFloat(getParameterByName('x'));
            const y= Number.parseFloat(getParameterByName('y'));
            const z = Number.parseFloat(getParameterByName('z'));
            const theta = Number.parseFloat(getParameterByName('theta'));
            const phi = Number.parseFloat(getParameterByName('phi'));
            let position;
            if (!(isNaN(x) || isNaN(y) || isNaN(z))) {
                position = {x, y, z}
            }
            placeCamera(position);

            const bboxcolor = [0xeeee00, 0x33ddaa];

            const url = `${path}/${data}`;

            const chainGroup = new itowns.THREE.Group();


            const info = document.createElement('span');
            document.getElementById('info').appendChild(info);
            document.getElementById('info').appendChild(document.createElement('br'));


            const pointcloud = new itowns.GeometryLayer('pointcloud', new itowns.THREE.Group());
            pointcloud.protocol = 'potreeconverter';
            pointcloud.url = url;
            pointcloud.pointSize = 0;

            pointcloud.preUpdate = itowns.PointCloudProcessing.preUpdate;
            pointcloud.update = itowns.PointCloudProcessing.update;
            pointcloud.densityThreshold = {
                min: 0.05,
                max: 0.15,
                lerp: true,
            };
            pointcloud.postUpdate = itowns.PointCloudProcessing.postUpdate;


            const pcRenderer = new itowns.PointCloudRenderer(view);
            const folder = menuGlobe.gui.addFolder('Point cloud Renderer');
            folder.add(pcRenderer.occlusion.parameters, 'enabled').name('occlusion').onChange(() => { view.notifyChange(true) });
            const occ = folder.addFolder('Occlusion parameters');
            occ.add(pcRenderer.occlusion.parameters, 'threshold').onChange(() => { view.notifyChange(true) });
            occ.add(pcRenderer.occlusion.parameters, 'showRemoved').onChange(() => { view.notifyChange(true) });
            folder.add(pcRenderer.inpainting.parameters, 'enabled').name('inpainting').onChange(() => { view.notifyChange(true) });
            const inp = folder.addFolder('Inpainting parameters');
            inp.add(pcRenderer.inpainting.parameters, 'fill_steps').onChange(() => { view.notifyChange(true) });
            inp.add(pcRenderer.inpainting.parameters, 'depth_contrib').min(0.0).max(1.0).onChange(() => { view.notifyChange(true) });
            folder.add(pcRenderer.edl.parameters, 'enabled').name('edl').onChange(() => { view.notifyChange(true) });
            const edl = folder.addFolder('EDL parameters');
            edl.add(pcRenderer.edl.parameters, 'strength').onChange(() => { view.notifyChange(true) });
            edl.add(pcRenderer.edl.parameters, 'directions').onChange(() => { view.notifyChange(true) });
            edl.add(pcRenderer.edl.parameters, 'radius').onChange(() => { view.notifyChange(true) });
            edl.add(pcRenderer.edl.parameters, 'n').onChange(() => { view.notifyChange(true) });

            var orthographicControl;

            const foobar = {
                export: () => {
                    console.log(deformationChain.export());
                },
                import: () => {
                    itowns.Fetcher.json('../dist/transfo.json').then((j) => {
                        deformationChain.import(j);
                        view.notifyChange(true);
                    });
                },
                transformations: true,
                help: true,
            }
            menuGlobe.gui.add(foobar, 'export');
            menuGlobe.gui.add(foobar, 'import');
            menuGlobe.gui.add(foobar, 'transformations').name('Recalage').onChange(() => view.notifyChange(true));
            menuGlobe.gui.add(foobar, 'help').name('Affiche l\'aide').onChange((v) => {
                document.getElementById('help').style.display = v ? 'block' : 'none';
            });
            let foooooooooooo = new itowns.THREE.Mesh(
                new itowns.THREE.PlaneGeometry(5, 20, 20)
                );
            foooooooooooo.frustumCulled = false;
            // view.scene.add(foooooooooooo);

            function render () {
              const g = view.mainLoop.gfxEngine;
              const r = g.renderer;

              r.setClearColor(new THREE.Color(0xffffff));

              const OPAQUE = 0;
              const POINTS = 1;
              const TRANSPARENT = 2;
              const renderBuckets = [
                [], [], []
              ];

              view.scene.traverse((c) => {
                if (c.material && c.visible && c.material.visible) {
                  if (c.isPoints) {
                    if (c.layer) {
                      if (view.getLayers(l => l.id === c.layer)[0].fx == false) {
                        renderBuckets[OPAQUE].push(c);
                      } else {
                        renderBuckets[POINTS].push(c);
                        c.material.visible = false;
                      }
                    } else {
                      // c is a point, but don't have any layer attached. Probably an annotation
                      // we put it in transparent because we want it above pointclouds
                      renderBuckets[TRANSPARENT].push(c);
                      c.material.visible = false
                    }
                  } else if (c.material.transparent) {
                    renderBuckets[TRANSPARENT].push(c);
                    c.material.visible = false;
                  } else {
                    renderBuckets[OPAQUE].push(c);
                  }
                }
              });


              // Draw OPAQUE first
              g.renderView(view);
              for (const obj of renderBuckets[OPAQUE]) {
                obj.material.visible = false;
              }

              // Draw POINTS
              for (const obj of renderBuckets[POINTS]) {
                obj.material.visible = true;
              }
              if (!fpControls || !(fpControls._isUserInteracting || fpControls.isUserInteracting())) {
                pcRenderer.renderView(view, 1.0);
              } else {
                // disable occlusion + inpaint while moving
                const occlusion = pcRenderer.occlusion.parameters.enabled;
                const inpainting = pcRenderer.inpainting.parameters.enabled;
                pcRenderer.occlusion.parameters.enabled = false;
                pcRenderer.inpainting.parameters.enabled = false;
                pcRenderer.renderView(view, 1.0);
                pcRenderer.occlusion.parameters.enabled = occlusion;
                pcRenderer.inpainting.parameters.enabled = inpainting;
                view.notifyChange(true);
              }
              for (const obj of renderBuckets[POINTS]) {
                obj.material.visible = false;
              }

              // Draw TRANSPARENT
              for (const obj of renderBuckets[TRANSPARENT]) {
                obj.material.visible = true;
              }
              g.renderer.render(view.scene, view.camera.camera3D);

              for (const obj of renderBuckets[OPAQUE]) {
                obj.material.visible = true;
              }
              for (const obj of renderBuckets[POINTS]) {
                obj.material.visible = true;
              }
            };

            view.render = () => {
                chainGroup.visible = foobar.transformations;
                if (!foobar.transformations) {
                    render();
                    return;
                }
                deformationChain.updateVisualRepresentation(view);

                yellowPointDnD.declareDragSources(deformationChain.getYellowPoints());
                redPointDnD.declareDragSources(deformationChain.getRedPoints());
                influenceHover.declareHoverableObjects(deformationChain.getInfluences());

                pointcloud.visible = true;
                pointcloud.opacity = 0.1;
                render();

                pointcloud.visible = true;
                pointcloud.opacity = 1.0;

                view.mainLoop.gfxEngine.renderer.clearDepth();

                const transformations = deformationChain.computeTransformations(view.camera.camera3D);


                for (let i = 0; i < transformations.length; i++) {
                    for (const transfo of transformations[i]) {
                        const transfoBox = transfo.box;

                        // debug selection
                        // foooooooooooo.geometry = new itowns.THREE.PlaneGeometry(
                        //     transfoBox.getSize().x, transfoBox.getSize().y);
                        // transfoBox.getCenter(foooooooooooo.position);
                        // foooooooooooo.position.z = 0;
                        // foooooooooooo.updateMatrixWorld(true);

                        pointcloud.group.traverse((pts) => {
                            if (pts.isPoints && pts.transfoCount < 16 && pts.tightbbox) { // NUM_TRANSFO
                                if (!pts.pts2dBox) {
                                    pts.pts2dBox = new itowns.THREE.Box2();
                                    pts.pts2dBox.expandByPoint(pts.tightbbox.min);
                                    pts.pts2dBox.expandByPoint(pts.tightbbox.max);
                                }

                                if (transfoBox.intersectsBox(pts.pts2dBox)) {
                                    if (pts.transfoCount < 0) {
                                        pts.transfoCount = 0;
                                    }
                                    const idx = pts.transfoCount++;
                                    pts.material.uniforms.useCustomColor.value = false;
                                    pts.material.uniforms.tColors.value[idx].copy(transfo.color);
                                    pts.material.uniforms.origin.value[idx].x = transfo.v1.x;
                                    pts.material.uniforms.origin.value[idx].y = transfo.v1.y;
                                    pts.material.uniforms.vec.value[idx].x = transfo.vec.x;
                                    pts.material.uniforms.vec.value[idx].y = transfo.vec.y;
                                    pts.material.uniforms.vec.value[idx].z = transfo.length;
                                    pts.material.uniforms.influence.value[idx].copy(transfo.influence);

                                    const mv = transfo.matrix.clone().multiply(pts.matrixWorld);
                                    pts.material.uniforms.transformations.value[idx].copy(mv);
                                    pts.material.uniforms.enableTransfo.value = pts.transfoCount;

                                    if (idx == 0) {
                                        pts.material.enableTransfo(true);
                                    }
                                }
                            }
                        });
                    }
                }

                view.mainLoop.gfxEngine.renderer.autoClearColor = false;
                view.mainLoop.gfxEngine.renderer.render(view.scene, view.camera.camera3D);

                pointcloud.group.traverse((pts) => {
                    if (pts.isPoints) {
                        if (pts.transfoCount > 0) {
                            pts.material.enableTransfo(false);
                        }
                        pts.transfoCount = -1;
                        pts.material.uniforms.enableTransfo.value = 0;
                    }
                });
            };

            let previousSelectionPoint;
            let newLineStarted;
            const foo = {
                new_line: function() {
                    deformationChain.newChain();
                    view.notifyChange(true);
                }
            };
            menuGlobe.gui.add(foo, 'new_line');

            const onMouseWheel = (event) => {
                event.preventDefault();
                if (!event.ctrlKey && !event.shiftKey) {
                    if(orthographicControl) {
                        orthographicControl.onMouseWheel(event);
                        return;
                    }
                }

                if (influenceHover.get()) {
                    var change = Math.sign(event.wheelDelta || -event.detail);

                    const influence = influenceHover.get();
                    deformationChain.updateScale(
                        influence.link,
                        event.shiftKey * change * 0.01,
                        event.ctrlKey * change);
                    view.notifyChange(true);
                }
            };
            view.mainLoop.gfxEngine.renderer.domElement.addEventListener('mousewheel', onMouseWheel);
            view.mainLoop.gfxEngine.renderer.domElement.addEventListener('DOMMouseScroll', onMouseWheel);


            view.scene.add(chainGroup);
            const deformationChain = new itowns.DeformationChain(chainGroup);
            const yellowPointDnD = new itowns.PointDnD(view);
            const redPointDnD = new itowns.PointDnD(view);
            const influenceHover = new itowns.HoverHelper(view);

            view.mainLoop.gfxEngine.renderer.domElement.addEventListener('contextmenu', (event) => {
                if (redPointDnD.hovered()) {
                    redPointDnD.hovered().onSelect();
                    view.notifyChange(true);
                    event.preventDefault();
                }
            });


            view.mainLoop.gfxEngine.renderer.domElement.addEventListener('dblclick', (event) => {
                if (!pointcloud.root) {
                    return;
                }
                const mouse = {
                    x: event.offsetX,
                    y: (event.currentTarget.height || event.currentTarget.offsetHeight) - event.offsetY,
                };

                const selection = itowns.PointCloudProcessing.selectAt(view, pointcloud, mouse);

                if (selection) {
                    const o = selection.points;
                    const positions = o.geometry.attributes.position.array;

                    const pos = new itowns.THREE.Vector3().fromArray(positions, 3 * selection.index);
                    pos.applyMatrix4(o.matrixWorld);

                    deformationChain.addPoint(pos);
                    view.notifyChange(true);
                }
            });

            let mouse;
            document.addEventListener('keyup', (event) => {
                if (event.key == 'Delete') {
                    // points are deletable
                    if (redPointDnD.hovered()) {
                        redPointDnD.hovered().onDelete();
                        view.notifyChange(true);
                    }

                }
            });

            document.addEventListener('mousemove', (event) => {
                influenceHover.clear();

                redPointDnD.onMouseMove(event);

                if (yellowPointDnD.onMouseMove(event)) {
                    // dnd in progress
                } else {
                    if (orthographicControl.onMouseMove(event)) {
                        // camera move
                    } else {
                        influenceHover.onMouseMove(event);
                    }
                }
            });


            document.addEventListener('mousedown', (event) => {
                event.preventDefault();

                if (yellowPointDnD.onMouseDown(event)) {
                    // console.log('Drag start');
                } else {
                    orthographicControl.onMouseDown(event);
                }
            });
            document.addEventListener('mouseup', (event) => {
                orthographicControl.onMouseUp(event);

                event.preventDefault();
                yellowPointDnD.onMouseUp();
            });

            var fpControls;
            if (view.camera.camera3D.isPerspectiveCamera) {
                fpControls = new itowns.FirstPersonControls(view, { focusOnClick: true, moveSpeed: 10     });

                view.camera.camera3D.rotation.x = itowns.THREE.Math.degToRad(theta || 90);
                view.camera.camera3D.rotation.y = itowns.THREE.Math.degToRad(phi || 0);
                fpControls.moveSpeed = 1000;
            } else {
                orthographicControl = new itowns.OrthoCameraControls(view);

                view.addLayer(pointcloud).then((pc) => {
                    debug.PointCloudDebug.initTools(view, pc, menuGlobe.gui);
                    view.notifyChange(true);
                    placeCamera(pc.root.bbox.getCenter(new THREE.Vector2()).clone().setZ(pc.root.bbox.max.z * 2));
                });
            }
            view.camera.camera3D.far = 200000;

            //  new debug.Debug(view, viewerDiv);
  var layer = new itowns.GeometryLayer('bati', view.scene);

  layer.preUpdate = itowns.pre3dTilesUpdate;
  layer.update = itowns.process3dTilesNode(
      itowns.$3dTilesCulling,
      itowns.$3dTilesSubdivisionControl
      );
  layer.name = name;
  layer.url = `${path}/resources/vectos3d/paris_cave_27591/tileset.json`;
  //layer.url = 'http://localhost:5000/getCity?city=paris_cave_27591';
  layer.protocol = '3d-tiles';
  layer.overrideMaterials = new itowns.THREE.MeshLambertMaterial();  // custom cesium shaders are not functional
  layer.overrideMaterials.emissive = new itowns.THREE.Color(0x00ff00);
  layer.overrideMaterials.side = itowns.THREE.DoubleSide;
  layer.type = 'geometry';
  layer.visible = true;
  // view.addLayer(layer);


const base = new itowns.THREE.Group();
base.position.z = 0;
base.updateMatrixWorld();
menuGlobe.gui.add(base.position, 'z').name('vecto2d z').onChange(() => {
    base.updateMatrixWorld();
    view.notifyChange(true);
});
view.scene.add(base);
for (const name of ['edf', 'eclairage', 'transport', 'edivers', 'arbre', 'eau', 'limites', 'concession','assainissement', 'cpcu', 'trottoir', 'gaz', 'vrd', 'mur', 'bati']) {
    var bati = new itowns.GeometryLayer(name, base);
    bati.preUpdate = itowns.pre3dTilesUpdate;
    bati.update = itowns.process3dTilesNode(
        itowns.$3dTilesCulling,
        itowns.$3dTilesSubdivisionControl
    );
    bati.name = name;
    bati.url = `http://localhost:8000/${name}/tileset.json`;
    bati.protocol = '3d-tiles'
    bati.overrideMaterials = new itowns.THREE.MeshLambertMaterial();
    bati.overrideMaterials.emissive = new itowns.THREE.Color(Math.random(), Math.random(), Math.random());
    bati.type = 'geometry';
    bati.visible = true;
    // bati.sseThreshold = 100;
    itowns.View.prototype.addLayer.call(view, bati);
}

const sun = new itowns.THREE.DirectionalLight();
sun.position.set(-0.5, 0, 1);
sun.updateMatrixWorld(true);
view.scene.add(sun);

function buildRasterLayer(name, view, minmax) {
  const extent = new itowns.Extent(view.referenceCrs, ...minmax);
  const anchor = new itowns.THREE.Group();
  const geom = new itowns.createPlanarLayer('geom' + name, extent, { object3d: anchor });
  geom.disableSkirt = true;
  view.addLayer(geom);
  view.addLayer({
    update: itowns.updateLayeredMaterialNodeImagery,
    url: `${path}/resources/rasters/${name}`,
    type: 'color',
    protocol: 'static',
    id: name,
    name,
    projection: extent.crs(),
    extent,
  }, geom);
  view.scene.add(anchor);
  return geom;
};
//var tile1 = buildRasterLayer('rectify2550.json', view, [1650689.12692239, 1651324.3935097859, 8181632.106679055, 8182058.308204069]);
var extent_toit2 = [1642789.4540314234, 1661353.0581432753, 8178853.903374324, 8193878.905985176]

const d = new debug.Debug(view, menuGlobe.gui);
//debug.createTileDebugUI(menuGlobe.gui, view , tile1, d);
// debug.createTileDebugUI(menuGlobe.gui, view , tile2, d);
//debug.createTileDebugUI(menuGlobe.gui, view , tile3, d);

// experimentation on geom couche

const THREE = itowns.THREE;

if (false) {
    var toit2Tex = itowns.Fetcher.texture(`${path}/resources/geols/toit2_aa.png`);
    var toit1Tex =  itowns.Fetcher.texture(`${path}/resources/geols/toit1_am.png`);
    Promise.all([toit2Tex.promise, toit1Tex.promise]).then(() => {
        console.log('creating plane');
        var planeGeom = new THREE.PlaneGeometry(extent_toit2[1] - extent_toit2[0] , 200);
        //var material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
        var fragmentShader =  document.getElementById( 'fragmentShader' ).textContent;
        console.log(toit1Tex.texture, toit2Tex.texture);
        var material = new THREE.ShaderMaterial( {
            uniforms: {
                geolTexture: { value: [toit1Tex.texture, toit2Tex.texture] },
                origin: { value: new THREE.Vector2(extent_toit2[0], extent_toit2[2]) },
                texWidth: { value: extent_toit2[1] - extent_toit2[0] },
                texHeight: { value: extent_toit2[3] - extent_toit2[2] },
            },
            vertexShader: document.getElementById( 'vertexShader' ).textContent,
            fragmentShader: fragmentShader,
        } );
        material.side = THREE.DoubleSide;
        material.transparent =  true;

        var plane = new THREE.Mesh( planeGeom, material );
        var planePosition = new THREE.Vector3(extent_toit2[0] + 0.5* (extent_toit2[1] - extent_toit2[0]),
                extent_toit2[2] + 0.5 * (extent_toit2[3] - extent_toit2[2]), 100);
        plane.position.copy(planePosition);
        plane.position.copy(view.camera.camera3D.position);
        plane.rotation.x = Math.PI / 2;
        plane.updateMatrixWorld(true);
        view.scene.add( plane );
        view.notifyChange(true);
    });



    function createGeolLayer(name) {
        var extent = new itowns.Extent('EPSG:3949', {"west": 1641937.719, "south": 8178530.736, "east": 1661357.209, "north": 8193900.331});
        var geomLayer = itowns.createPlanarLayer(`geom_${name}`, extent, {
            maxSubdivisionLevel: 10,
        });
        geomLayer.disableSkirt = true;
        geomLayer.materialOptions = {
            noDataValue: -1000,
            discardNoData: true,
            outlineColor: new itowns.THREE.Color(
                Math.random(),
                Math.random(),
                Math.random()),
        };
        geomLayer.noTextureColor = geomLayer.materialOptions.outlineColor;
        view.addLayer(geomLayer);
        var layer = {
            update: itowns.updateLayeredMaterialNodeElevation,
            url: `./resources/geols/${name}/metadata_max.json`,
            type: 'elevation',
            mimetype: 'xbil',
            protocol: 'static',
            noDataValue: -300,
            id: name,
            name: name,
            projection: extent.crs(),
            extent: extent,
        };
        geomLayer.showOutline = true;
        geomLayer.materialOptions = { side: itowns.THREE.DoubleSide,  noDataValue: -500, discardNoData: true  };
        geomLayer.disableSkirt = true;
        view.addLayer(layer, geomLayer);
        geomLayer.visible = false;

        debug.createTileDebugUI(menuGlobe.gui, view , geomLayer, d);
    }
    for (const tttt of [ 'mur_cb', 'toit12_cb', 'toit11_mm', 'toit10_ap', 'toit9_sa',
                  'toit8_fg', 'toit7_ss', 'toit6_cg', 'toit5_metc', 'toit4_sb',
                  'toit3_so', 'toit_tb_bel', 'toit_tb_mon', 'toit_mh_bel',
                  'toit_mh_mon', 'toit_sf_bel', 'toit_sf_mon', 'toit2_aa',
                  'toit1_am']) {
        createGeolLayer(tttt);
    }
}
        </script>

    </body>
</html>
