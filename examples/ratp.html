<!DOCTYPE html>
<html>
    <head>
        <title>RATP PC viewer</title>

        <style type="text/css">
            html {height: 100%;}
            body { margin: 0; overflow:hidden; height:100%}

            #viewerDiv {
                margin : auto auto;
                width: 100%;
                height: 100%;
                padding: 0;
            }

            #menuDiv {position: absolute; top:0px; margin-left: 0px;}
            #info {
                color: black;
                position: absolute;
                top: 0px;
                right: 0px;
                padding: 5px;
                z-index: 100;

                z-index: 100;
                background-color: white;
                border: 2px solid black;
                border-radius: 5px;
            }
        </style>

        <meta charset="UTF-8">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="GUI/dat.gui/dat.gui.min.js"></script>
    </head>
    <body>
        <div id="viewerDiv"></div>
        <div id="info">

        </div>
        <div id="splat"></div>

        <script src="/examples/GUI/GuiTools.js"></script>
        <script src="/dist/itowns.js"></script>
        <script src="/dist/debug.js"></script>

        <script id="vertexShader" type="text/shader">
#include <common>
#include <logdepthbuf_pars_vertex>
varying vec2 vUv;
uniform vec2 origin;
uniform float texWidth;
uniform float texHeight;
varying float realZ;
void main() {
    vec4 realPosition = modelMatrix * vec4(position, 1.0);
    realZ = realPosition.z;
    vUv = vec2((realPosition.x - origin.x) / texWidth , (realPosition.y - origin.y) / texHeight);

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0);
    #include <logdepthbuf_vertex>
}

        </script>
        <script id="fragmentShader" type="text/shader">
#include <common>
#include <logdepthbuf_pars_fragment>
uniform sampler2D geolTexture[2];
varying vec2 vUv;
varying float realZ;

float convertFromRgb(const in float color, const in float min, const in float max) {
    if (color == 0.0) return 0.0;
    return min + color * (max - min);
}
void main() {
// get z for texture 1
    vec4 tex1Value = texture2D(geolTexture[0], vUv);
    vec4 tex2Value = texture2D(geolTexture[1], vUv);

    float z1 = convertFromRgb(tex1Value.r, 20.0, 45.0);
    float z2 = convertFromRgb(tex2Value.r, 14.0, 71.0);

    if (realZ < z2) {
        gl_FragColor = vec4(1, 0, 0, 0.3);
    } else if (realZ < z1) {
        gl_FragColor = vec4(0, 1, 0, 0.3);
    } else {
        gl_FragColor = vec4(0, 0, 1, 0.3);
    }

    //gl_FragColor = tex1Value;
    //gl_FragColor = vec4(1,1,0,vUv.x);

    #include <logdepthbuf_fragment>
}
        </script>
        <script type="text/javascript">

            /* global itowns,document,GuiTools*/
            const viewerDiv = document.getElementById('viewerDiv');

            itowns.THREE.Object3D.DefaultUp.set(0, 0, 1);

            itowns.proj4.defs('EPSG:3949',
                '+proj=lcc +lat_1=48.25 +lat_2=49.75 +lat_0=49 +lon_0=3 +x_0=1700000 +y_0=8200000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
            itowns.proj4.defs('EPSG:27561',
                '+proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=0 +k_0=0.999877341 +x_0=600000 +y_0=200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs');
            const bb =  {
                "lx": 1650798.7022,
                "ly": 8181453.994,
                "lz": 35.9102,
                "ux": 1651206.1331,
                "uy": 8181861.4249,
                "uz": 443.3411000000358
            };

            const bbox = new itowns.Extent(
                'EPSG:3949',
                bb.lx, bb.ux,
                bb.ly, bb.uy);

            const view = new itowns.View('EPSG:3949', viewerDiv);
            const menuGlobe = new GuiTools('menuDiv', view, 460);

            function placeCamera(position) {
                if (position) {
                    view.camera.camera3D.position.set(position.x, position.y, position.z);
                } else {
                    view.camera.camera3D.position.set(1651083.037, 8181534.45, 41.03);
                }
                view.notifyChange(true);
            }

            // point cloud
            function getParameterByName(name, url) {
                if (!url) url = window.location.href;
                name = name.replace(/[\[\]]/g, "\\$&");
                var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                    results = regex.exec(url);
                if (!results) return null;
                if (!results[2]) return '';
                return decodeURIComponent(results[2].replace(/\+/g, " "));
            }
            const withoutQueryStr = window.location.origin + window.location.pathname;
            const path = withoutQueryStr.substr(0, withoutQueryStr.lastIndexOf('/'));
            const data = getParameterByName('data');
            const x = Number.parseFloat(getParameterByName('x'));
            const y= Number.parseFloat(getParameterByName('y'));
            const z = Number.parseFloat(getParameterByName('z'));
            const theta = Number.parseFloat(getParameterByName('theta'));
            const phi = Number.parseFloat(getParameterByName('phi'));
            let position;
            if (!(isNaN(x) || isNaN(y) || isNaN(z))) {
                position = {x, y, z}
            }
            placeCamera(position);

            const bboxcolor = [0xeeee00, 0x33ddaa];

            const url = `${path}/${data}`;


            const info = document.createElement('span');
            document.getElementById('info').appendChild(info);
            document.getElementById('info').appendChild(document.createElement('br'));


            const pointcloud = new itowns.GeometryLayer('pointcloud', view.scene);
            pointcloud.protocol = 'potreeconverter';
            pointcloud.url = url;

            pointcloud.preUpdate = itowns.PointCloudProcessing.preUpdate;
            pointcloud.update = itowns.PointCloudProcessing.update;
            pointcloud.densityThreshold = {
                min: 0.05,
                max: 0.15,
                lerp: true,
            };
            pointcloud.postUpdate = itowns.PointCloudProcessing.postUpdate;


            const pcRenderer = new itowns.PointCloudRenderer(view);
            const folder = menuGlobe.gui.addFolder('Point cloud Renderer');
            folder.add(pcRenderer.occlusion.parameters, 'enabled').name('occlusion').onChange(() => { view.notifyChange(true) });
            const occ = folder.addFolder('Occlusion parameters');
            occ.add(pcRenderer.occlusion.parameters, 'threshold').onChange(() => { view.notifyChange(true) });
            occ.add(pcRenderer.occlusion.parameters, 'showRemoved').onChange(() => { view.notifyChange(true) });
            folder.add(pcRenderer.inpainting.parameters, 'enabled').name('inpainting').onChange(() => { view.notifyChange(true) });
            const inp = folder.addFolder('Inpainting parameters');
            inp.add(pcRenderer.inpainting.parameters, 'fill_steps').onChange(() => { view.notifyChange(true) });
            inp.add(pcRenderer.inpainting.parameters, 'depth_contrib').min(0.0).max(1.0).onChange(() => { view.notifyChange(true) });
            folder.add(pcRenderer.edl.parameters, 'enabled').name('edl').onChange(() => { view.notifyChange(true) });
            const edl = folder.addFolder('EDL parameters');
            edl.add(pcRenderer.edl.parameters, 'strength').onChange(() => { view.notifyChange(true) });
            edl.add(pcRenderer.edl.parameters, 'directions').onChange(() => { view.notifyChange(true) });
            edl.add(pcRenderer.edl.parameters, 'radius').onChange(() => { view.notifyChange(true) });
            edl.add(pcRenderer.edl.parameters, 'n').onChange(() => { view.notifyChange(true) });


            view.render = () => {
                const g = view.mainLoop.gfxEngine;
                const r = g.renderer;

                // update stats
                if (pointcloud && pointcloud.counters) {
                    info.textContent = `Nb points: ${pointcloud.counters.displayedCount} (${Math.floor(100 * pointcloud.counters.displayedCount / pointcloud.counters.pointCount)} %) (${view.mainLoop.gfxEngine.renderer.info.memory.geometries})`;
                }

                r.setClearColor(new itowns.THREE.Color(0xffffff));

                // disable pointcloud layer
                pointcloud.visible = false;
                // render
                view.mainLoop.gfxEngine.renderView(view);
                // enable only pointcloud
                pointcloud.visible = true;
                const prev = view.camera.camera3D.layers.mask;
                view.camera.camera3D.layers.mask = 1 << pointcloud.threejsLayer

                if (fpControls && !(fpControls._isUserInteracting || fpControls.isUserInteracting())) {
                    // disable occlusion + inpaint while moving
                    const occlusion = pcRenderer.occlusion.parameters.enabled;
                    const inpainting = pcRenderer.inpainting.parameters.enabled;
                    pcRenderer.occlusion.enabled = false;
                    pcRenderer.occlusion.enabled = false;
                    pcRenderer.renderView(view, pointcloud.opacity);
                    pcRenderer.occlusion.parameters.enabled = occlusion;
                    pcRenderer.inpainting.parameters.enabled = inpainting;
                } else {
                    pcRenderer.renderView(view, pointcloud.opacity);
                }

                view.camera.camera3D.layers.mask = prev;
            };


            const selectionGroup = new itowns.THREE.Group();

            view.mainLoop.gfxEngine.renderer.domElement.addEventListener('dblclick', (event) => {
                if (!pointcloud.root) {
                    return;
                }
                if (!selectionGroup.parent) {
                    // add selectionGroup to the scene after root, in order for selected points
                    // to be displayed after (alternative solution: use renderOrder)
                    view.scene.add(selectionGroup);
                    selectionGroup.frustumCulled = false;
                }

                selectionGroup.visible = false;
                view.scene.traverse((o) => {
                    if (o.isPoints && o.baseId) {
                        o.material.enablePicking(true);
                    }
                });

                const mouse = {
                    x: event.offsetX,
                    y: (event.currentTarget.height || event.currentTarget.offsetHeight) - event.offsetY,
                };

                const buffer = view.mainLoop.gfxEngine.renderViewTobuffer(
                        view, view.mainLoop.gfxEngine.fullSizeRenderTarget,
                        mouse.x, mouse.y, 1, 1);

                // see PointCloudProvider and the construction of unique_id
                const objId = (buffer[0] << 8) | buffer[1];
                const index = (buffer[2] << 8) | buffer[3];

                const i = (objId << 16) | index;
                console.log("objId, index, i", objId, index, i);

                view.scene.traverse((o) => {
                    if (o.isPoints && o.baseId) {
                        if (o.baseId == objId) {
                            console.log('found o', o);
                            const positions = o.geometry.attributes.position.array;
                            const uids = o.geometry.attributes['unique_id'].array;

                            const g = new itowns.THREE.BufferGeometry();

                            const p = positions.slice(3 * index + 0, 3 * index + 3);
                            const uid = uids.slice(4 * index + 0, 4 * index + 4);
                            const c = Uint8Array.of(255, 0, 0, 255);
                            console.log('NEW SELECTION', index, p, uid, c);
                            g.addAttribute('position', new itowns.THREE.BufferAttribute(p, 3));
                            console.log('position', p);
                            g.addAttribute('color', new itowns.THREE.BufferAttribute(c, 4, true));
                            g.addAttribute('unique_id', new itowns.THREE.BufferAttribute(uids, 4, true));

                            const m = new itowns.PointsMaterial(5);

                            m.depthTest = false;
                            const pickedPoint = new itowns.THREE.Points(g, m);
                            pickedPoint.position.copy(o.position);
                            pickedPoint.scale.copy(o.scale);
                            pickedPoint.updateMatrix();
                            pickedPoint.updateMatrixWorld(true);

                            pickedPoint.layers.set(pointcloud.threejsLayer);
                            pickedPoint.frustumCulled = false;
                            selectionGroup.add(pickedPoint);

                            selectionGroup.layers.set(pointcloud.threejsLayer);
                            console.log('done');

                            // view.camera.camera3D.lookAt(p.clone().applyMatrix4(b.matrixWorld));
                        }

                        o.material.enablePicking(false);
                    }

                });

                selectionGroup.visible = true;
                view.notifyChange(true);
            });

            const sprayTool = new itowns.SprayTools(view);
            // view.controls.push(sprayTool);

            const fpControls = new itowns.FirstPersonControls(view, { focusOnClick: true, moveSpeed: 100 });

            view.camera.camera3D.rotation.x = itowns.THREE.Math.degToRad(theta || 100);
            view.camera.camera3D.rotation.z = itowns.THREE.Math.degToRad(phi || 196);

            view.addLayer(pointcloud).then((pc) => {
                debug.PointCloudDebug.initTools(view, pc, menuGlobe.gui);
                view.notifyChange(true);
            });
            view.camera.camera3D.far = 200000;

            //  new debug.Debug(view, viewerDiv);
  var layer = new itowns.GeometryLayer('bati', view.scene);

  layer.preUpdate = itowns.pre3dTilesUpdate;
  layer.update = itowns.process3dTilesNode(
      itowns.$3dTilesCulling,
      itowns.$3dTilesSubdivisionControl
      );
  layer.name = name;
  layer.url = `${path}/resources/vectos3d/paris_cave_27591/tileset.json`;
  //layer.url = 'http://localhost:5000/getCity?city=paris_cave_27591';
  layer.protocol = '3d-tiles';
  layer.overrideMaterials = new itowns.THREE.MeshLambertMaterial();  // custom cesium shaders are not functional
  layer.overrideMaterials.emissive = new itowns.THREE.Color(0x00ff00);
  layer.overrideMaterials.side = itowns.THREE.DoubleSide;
  layer.type = 'geometry';
  layer.visible = true;
  // view.addLayer(layer);


const base = new itowns.THREE.Group();
base.position.z = 50;
base.updateMatrixWorld();
menuGlobe.gui.add(base.position, 'z').name('vecto2d z').onChange(() => {
    base.updateMatrixWorld();
    view.notifyChange(true);
});
view.scene.add(base);
for (const name of ['edf', 'eclairage', 'transport', 'edivers', 'arbre', 'eau', 'limites', 'concession','assainissement', 'cpcu', 'trottoir', 'gaz', 'vrd', 'mur', 'bati']) {
    var bati = new itowns.GeometryLayer(name, base);
    bati.preUpdate = itowns.pre3dTilesUpdate;
    bati.update = itowns.process3dTilesNode(
        itowns.$3dTilesCulling,
        itowns.$3dTilesSubdivisionControl
    );
    bati.name = name;
    bati.url = `http://localhost:8000/${name}/tileset.json`;
    bati.protocol = '3d-tiles'
    bati.overrideMaterials = new itowns.THREE.MeshLambertMaterial();
    bati.overrideMaterials.emissive = new itowns.THREE.Color(Math.random(), Math.random(), Math.random());
    bati.type = 'geometry';
    bati.visible = true;
    itowns.View.prototype.addLayer.call(view, bati);
}

const sun = new itowns.THREE.DirectionalLight();
sun.position.set(-0.5, 0, 1);
sun.updateMatrixWorld(true);
view.scene.add(sun);

function buildRasterLayer(name, view, minmax) {
  const extent = new itowns.Extent(view.referenceCrs, ...minmax);
  const anchor = new itowns.THREE.Group();
  const geom = new itowns.createPlanarLayer('geom' + name, extent, { object3d: anchor });
  geom.disableSkirt = true;
  view.addLayer(geom);
  view.addLayer({
    update: itowns.updateLayeredMaterialNodeImagery,
    url: `${path}/resources/rasters/${name}`,
    type: 'color',
    protocol: 'static',
    id: name,
    name,
    projection: extent.crs(),
    extent,
  }, geom);
  view.scene.add(anchor);
  return geom;
};
var tile1 = buildRasterLayer('rectify2550.json', view, [1650689.12692239, 1651324.3935097859, 8181632.106679055, 8182058.308204069]);
var extent_toit2 = [1642789.4540314234, 1661353.0581432753, 8178853.903374324, 8193878.905985176]

const d = new debug.Debug(view, menuGlobe.gui);
//debug.createTileDebugUI(menuGlobe.gui, view , tile1, d);
debug.createTileDebugUI(menuGlobe.gui, view , tile2, d);
debug.createTileDebugUI(menuGlobe.gui, view , tile3, d);

// experimentation on geom couche

const THREE = itowns.THREE;

var toit2Tex = itowns.Fetcher.texture(`${path}/resources/geols/toit2_aa.png`);
var toit1Tex =  itowns.Fetcher.texture(`${path}/resources/geols/toit1_am.png`);
Promise.all([toit2Tex.promise, toit1Tex.promise]).then(() => {
    console.log('creating plane');
    var planeGeom = new THREE.PlaneGeometry(extent_toit2[1] - extent_toit2[0] , 200);
    //var material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
    var fragmentShader =  document.getElementById( 'fragmentShader' ).textContent;
    console.log(toit1Tex.texture, toit2Tex.texture);
    var material = new THREE.ShaderMaterial( {
        uniforms: {
            geolTexture: { value: [toit1Tex.texture, toit2Tex.texture] },
            origin: { value: new THREE.Vector2(extent_toit2[0], extent_toit2[2]) },
            texWidth: { value: extent_toit2[1] - extent_toit2[0] },
            texHeight: { value: extent_toit2[3] - extent_toit2[2] },
        },
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: fragmentShader,
    } );
    material.side = THREE.DoubleSide;
    material.transparent =  true;

    var plane = new THREE.Mesh( planeGeom, material );
    var planePosition = new THREE.Vector3(extent_toit2[0] + 0.5* (extent_toit2[1] - extent_toit2[0]),
            extent_toit2[2] + 0.5 * (extent_toit2[3] - extent_toit2[2]), 100);
    plane.position.copy(planePosition);
    plane.rotation.x = Math.PI / 2;
    plane.updateMatrixWorld(true);
    view.scene.add( plane );
    view.notifyChange(true);
});
        </script>

    </body>
</html>
