<html>
    <head>
        <title>Itowns - Orthographic Camera Example</title>

        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="css/example.css">
        <link rel="stylesheet" type="text/css" href="css/loading_screen.css">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
        <div id="viewerDiv">
            <button id="toggle-serpent">Toggle serpent</button>
        </div>
        <script src="../dist/itowns.js"></script>
        <script src="js/loading_screen.js"></script>
        <script type="text/javascript">

            /* global itowns, renderer */
            // # Orthographic viewer

            // Define geographic extent: CRS, min/max X, min/max Y
            var extent = new itowns.Extent(
                'EPSG:3857',
                -20026376.39, 20026376.39,
                -20048966.10, 20048966.10);

            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            var viewerDiv = document.getElementById('viewerDiv');

            let center = { x: 328745, y: 5904608 };
            let halfHeight = (6800000 - 5000000) / 2;
            let camera = new itowns.THREE.OrthographicCamera(
                    // left and right determined empirically
                    -628337.4524312895,
                    2111620.264270613,
                    center.y + halfHeight,
                    center.y - halfHeight,
                    0,
                    1000);

            // Instanciate PlanarView
            var view = new itowns.PlanarView(
                    viewerDiv, extent, { maxSubdivisionLevel: 10, camera: camera });

            var onMouseWheel = function onMouseWheel(event) {
                var change = 1 - (Math.sign(event.wheelDelta || -event.detail) * 0.1);

                var halfNewWidth = (view.camera.camera3D.right - view.camera.camera3D.left) * change * 0.5;
                var halfNewHeight = (view.camera.camera3D.top - view.camera.camera3D.bottom) * change * 0.5;
                var cx = (view.camera.camera3D.right + view.camera.camera3D.left) * 0.5;
                var cy = (view.camera.camera3D.top + view.camera.camera3D.bottom) * 0.5;

                view.camera.camera3D.left = cx - halfNewWidth;
                view.camera.camera3D.right = cx + halfNewWidth;
                view.camera.camera3D.top = cy + halfNewHeight;
                view.camera.camera3D.bottom = cy - halfNewHeight;

                view.notifyChange(view.camera.camera3D, true);
            };

            var dragStartPosition;
            var dragCameraStart;

            // By default itowns' tiles geometry have a "skirt" (ie they have a height),
            // but in case of orthographic we don't need this feature, so disable it
            view.tileLayer.disableSkirt = true;
            view.tileLayer.showOutline = true;

            // Add an TMS imagery layer
            /*view.addLayer({
                type: 'color',
                protocol: 'xyz',
                id: 'OPENSM',
                // eslint-disable-next-line no-template-curly-in-string
                url: 'http://geomarketer.oslandia.io/osm_standard/${z}/${x}/${y}.png',
                networkOptions: { crossOrigin: 'use-credentials' },
                extent: [extent.west(), extent.east(), extent.south(), extent.north()],
                projection: 'EPSG:3857',
                options: {
                    zoom: { min: 0, max: 25 },
                    attribution: {
                        name: 'OpenStreetMap',
                        url: 'http://www.openstreetmap.org/',
                    },
                },
                updateStrategy: {
                    type: itowns.STRATEGY_DICHOTOMY,
                },
                sequence: 1
            });*/
            view.addLayer({
                type: 'color',
                protocol: 'xyz',
                id: 'OPEN_label',
                // eslint-disable-next-line no-template-curly-in-string
                url: 'http://geomarketer.oslandia.io/osm_label/${z}/${x}/${y}.png',
                networkOptions: { crossOrigin: 'use-credentials' },
                extent: [extent.west(), extent.east(), extent.south(), extent.north()],
                projection: 'EPSG:3857',
                options: {
                    zoom: { min: 0, max: 25 },
                    attribution: {
                        name: 'OpenStreetMap',
                        url: 'http://www.openstreetmap.org/',
                    },
                },
                updateStrategy: {
                    type: itowns.STRATEGY_DICHOTOMY,
                },
                sequence: 2
            });

            viewerDiv.addEventListener('DOMMouseScroll', onMouseWheel);
            viewerDiv.addEventListener('mousewheel', onMouseWheel);

            viewerDiv.addEventListener('mousedown', function mouseDown(event) {
                dragStartPosition = view.eventToViewCoords(event).clone();
                dragCameraStart = {
                    left: view.camera.camera3D.left,
                    right: view.camera.camera3D.right,
                    top: view.camera.camera3D.top,
                    bottom: view.camera.camera3D.bottom,
                };
            });
            var obj;
            viewerDiv.addEventListener('mousemove', function mouseMove(event) {
                var width;
                var deltaX;
                var deltaY;
                var newpos;
                if (dragStartPosition) {
                    newpos = view.eventToViewCoords(event);
                    width = view.camera.camera3D.right - view.camera.camera3D.left;
                    deltaX = width * (newpos.x - dragStartPosition.x) / -viewerDiv.clientWidth;
                    deltaY = width * (newpos.y - dragStartPosition.y) / viewerDiv.clientHeight;

                    view.camera.camera3D.left = dragCameraStart.left + deltaX;
                    view.camera.camera3D.right = dragCameraStart.right + deltaX;
                    view.camera.camera3D.top = dragCameraStart.top + deltaY;
                    view.camera.camera3D.bottom = dragCameraStart.bottom + deltaY;
                    view.notifyChange(view.camera.camera3D, true);
                }

                if (obj) {
                    const intersects = view.pickObjectsAt(
                            event,
                            null,
                            obj);
                }


            });
            viewerDiv.addEventListener('mouseup', function mouseUp() {
                dragStartPosition = undefined;
            });


            /* itowns.Fetcher.json('/test2.geojson').then(function (json) {
                itowns.GeoJsonParser.parse(json, { crsOut: 'EPSG:3857' } ).then(features => {
                    obj = itowns.Feature2Mesh.convert()(features);
                    obj.traverse(o => {
                        o.renderOrder = 1;
                        if (o.material) {
                            o.material.transparent = true;
                            o.material.opacity = 0.5;
                        }
                    });
                    view.scene.add(obj);
                    view.notifyChange(obj, true);
                });
            }); */
            /*itowns.Fetcher.json('/test3.geojson').then(function (geojson) {
                const THREE = itowns.THREE;
                for (const jsonFeat of geojson.features) {
                    // transform this geom into a multilinestring
                    // multipolygon is an array of polygon, itself and array of outer ring and hole rings
                    // we just want an array of linestring, one for the outer ring and one for each hole
                    const newCoords = []
                        for (let i = 0; i < jsonFeat.geometry.coordinates.length; i++) {
                            const poly = jsonFeat.geometry.coordinates[i];
                            for (let j = 0; j < poly.length; j++) {
                                const coord = poly[j];
                                newCoords.push(coord);
                            }
                        }
                    const geometry = {
                        type: 'MultiLineString',
                        coordinates: newCoords,
                    };
                    const copy = {
                        type: 'Feature',
                        properties: JSON.parse(JSON.stringify(jsonFeat.properties)),
                        geometry
                    };
                    itowns.GeoJsonParser.parse(copy, { crsOut: 'EPSG:3857' }).then(feat => {
                        const mesh = itowns.Feature2Mesh.convert({
                            altitude: 11,
                        })(feat);
                        mesh.material.vertexColors = THREE.NoColors;
                        mesh.material.color = new THREE.Color(0xff0000);
                        mesh.traverse(o => {
                            o.renderOrder = 2;
                        });
                        view.scene.add(mesh);
                        view.notifyChange(mesh, true);
                    });
                }
            }).catch( e=> console.error(e));*/
            const red = new itowns.THREE.Color('red');
            const yellow = new itowns.THREE.Color('yellow');

            itowns.Fetcher.json( '/examples/serpent.geojson').then(json => {
                const serpent = {
                    type: 'color',
                    geojson: json,
                    protocol: 'rasterizer',
                    id: 'serpent',
                    name: 'serpent',
                    transparent: true,
                    style: {
                        strokeCap: 'round',
                    },
                    level: {
                        min: 3,
                        max: 999
                    },
                    options: {
                        featureCb: function (feat) {
                            feat.properties.stroke = feat.properties.tmtm > 500000 ? red.getStyle() : yellow.getStyle();
                            feat.properties['stroke-width'] = feat.properties.tmtm > 500000 ? '10.0': '1.0';
                        }
                    }
                };
                view.addLayer(serpent);
                document.getElementById('toggle-serpent').addEventListener('click', (e) => {
                    const existing = view.getLayers(l => l.id == 'serpent')[0];
                    if (existing) {
                        view.removeLayer(existing);
                    } else {
                        view.addLayer(serpent);
                    }
                });
            }).catch( e => console.error(e));
            /*itowns.Fetcher.json('../test2.geojson').then(json => {
                const obj = itowns.Feature2Mesh.convert()(itowns.GeoJsonParser.parse('EPSG:3857', json));
                obj.children[0].renderOrder = 1;
                view.scene.add(obj);
                view.notifyChange(true);
            }); */


            // Request redraw
            view.notifyChange(null, true);
        </script>
    </body>
</html>
