<html>
    <head>
        <title>Itowns - Orthographic Camera Example</title>

        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="css/example.css">
        <link rel="stylesheet" type="text/css" href="css/loading_screen.css">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
        <div id="viewerDiv"></div>
        <script src="../dist/itowns.js"></script>
        <script src="js/loading_screen.js"></script>
        <script type="text/javascript">

            /* global itowns, renderer */
            // # Orthographic viewer

            // Define geographic extent: CRS, min/max X, min/max Y
            var extent = new itowns.Extent(
                'EPSG:3857',
                -20026376.39, 20026376.39,
                -20048966.10, 20048966.10);

            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            var viewerDiv = document.getElementById('viewerDiv');

            var r = viewerDiv.clientWidth / viewerDiv.clientHeight;
            var camera = new itowns.THREE.OrthographicCamera(
                extent.west(), extent.east(),
                extent.east() / r, extent.west() / r,
                0, 1000);

            // Instanciate PlanarView
            var view = new itowns.PlanarView(
                    viewerDiv, extent, { maxSubdivisionLevel: 10, camera: camera });

            var onMouseWheel = function onMouseWheel(event) {
                var change = 1 - (Math.sign(event.wheelDelta || -event.detail) * 0.1);

                var halfNewWidth = (view.camera.camera3D.right - view.camera.camera3D.left) * change * 0.5;
                var halfNewHeight = (view.camera.camera3D.top - view.camera.camera3D.bottom) * change * 0.5;
                var cx = (view.camera.camera3D.right + view.camera.camera3D.left) * 0.5;
                var cy = (view.camera.camera3D.top + view.camera.camera3D.bottom) * 0.5;

                view.camera.camera3D.left = cx - halfNewWidth;
                view.camera.camera3D.right = cx + halfNewWidth;
                view.camera.camera3D.top = cy + halfNewHeight;
                view.camera.camera3D.bottom = cy - halfNewHeight;

                view.notifyChange(view.camera.camera3D, true);
            };

            var dragStartPosition;
            var dragCameraStart;

            // By default itowns' tiles geometry have a "skirt" (ie they have a height),
            // but in case of orthographic we don't need this feature, so disable it
            view.tileLayer.disableSkirt = true;

            // Add an TMS imagery layer
            view.addLayer({
                type: 'color',
                protocol: 'xyz',
                id: 'OPENSM',
                // eslint-disable-next-line no-template-curly-in-string
                url: 'http://c.tile.stamen.com/watercolor/${z}/${x}/${y}.jpg',
                networkOptions: { crossOrigin: 'anonymous' },
                extent: [extent.west(), extent.east(), extent.south(), extent.north()],
                projection: 'EPSG:3857',
                options: {
                    attribution: {
                        name: 'OpenStreetMap',
                        url: 'http://www.openstreetmap.org/',
                    },
                },
                updateStrategy: {
                    type: itowns.STRATEGY_DICHOTOMY,
                },
            });

            viewerDiv.addEventListener('DOMMouseScroll', onMouseWheel);
            viewerDiv.addEventListener('mousewheel', onMouseWheel);

            viewerDiv.addEventListener('mousedown', function mouseDown(event) {
                dragStartPosition = view.eventToViewCoords(event).clone();
                dragCameraStart = {
                    left: view.camera.camera3D.left,
                    right: view.camera.camera3D.right,
                    top: view.camera.camera3D.top,
                    bottom: view.camera.camera3D.bottom,
                };
            });
            var obj;
            viewerDiv.addEventListener('mousemove', function mouseMove(event) {
                var width;
                var deltaX;
                var deltaY;
                var newpos;
                if (dragStartPosition) {
                    newpos = view.eventToViewCoords(event);
                    width = view.camera.camera3D.right - view.camera.camera3D.left;
                    deltaX = width * (newpos.x - dragStartPosition.x) / -viewerDiv.clientWidth;
                    deltaY = width * (newpos.y - dragStartPosition.y) / viewerDiv.clientHeight;

                    view.camera.camera3D.left = dragCameraStart.left + deltaX;
                    view.camera.camera3D.right = dragCameraStart.right + deltaX;
                    view.camera.camera3D.top = dragCameraStart.top + deltaY;
                    view.camera.camera3D.bottom = dragCameraStart.bottom + deltaY;
                    view.notifyChange(view.camera.camera3D, true);
                }

                if (obj) {
                    const intersects = view.pickObjectsAt(
                            event,
                            null,
                            obj);
                    console.log(intersects);
                }


            });
            viewerDiv.addEventListener('mouseup', function mouseUp() {
                dragStartPosition = undefined;
            });


            itowns.Fetcher.json('../test.geojson').then(function (json) {
                itowns.GeoJsonParser.parse(json, { crsOut: 'EPSG:3857' } ).then(features => {
                    obj = itowns.Feature2Mesh.convert()(features);
                    obj.traverse(o => {
                        o.renderOrder = 1;
                        if (o.material) {
                            o.material.transparent = true;
                            o.material.opacity = 0.3;
                        }
                    });
                    view.scene.add(obj);
                    view.notifyChange(obj, true);
                });
            });
            const red = new itowns.THREE.Color('red');
            const yellow = new itowns.THREE.Color('yellow');
            itowns.Fetcher.json( 'http://localhost:8080/examples/serpent.json').then(json => {
                view.addLayer({
                    type: 'color',
                    geojson: json,
                    protocol: 'rasterizer',
                    id: 'serpent',
                    name: 'serpent',
                    transparent: true,
                    style: {
                        strokeCap: 'round',
                    },
                    options: {
                        featureCb: function (feat) {
                            feat.properties.stroke = feat.properties.tmtm > 500000 ? red.getStyle() : yellow.getStyle();
                            feat.properties['stroke-width'] = feat.properties.tmtm > 500000 ? '10.0': '1.0';
                        }
                    }
                });
            }).catch( e => console.error(e));
            /*itowns.Fetcher.json('../test2.geojson').then(json => {
                const obj = itowns.Feature2Mesh.convert()(itowns.GeoJsonParser.parse('EPSG:3857', json));
                obj.children[0].renderOrder = 1;
                view.scene.add(obj);
                view.notifyChange(true);
            }); */


            // Request redraw
            view.notifyChange(null, true);
        </script>
    </body>
</html>
